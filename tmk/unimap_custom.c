// Generated by KLFC 1.5.7
// https://github.com/39aldo39/klfc

#include "unimap_trans.h"
#include "action_util.h"
#include "action_layer.h"

enum function_id {
    F_MODIFIER,
};

enum macro_id {
    LIG__asciitilde_,
    LIG_Q,
    LIG_W,
    LIG_E,
    LIG_R,
    LIG_T,
    LIG_Y,
    LIG_U,
    LIG_I,
    LIG_O,
    LIG_P,
    LIG__parenleft_,
    LIG__parenright_,
    LIG_A,
    LIG_S,
    LIG_D,
    LIG_F,
    LIG_G,
    LIG_H,
    LIG_J,
    LIG_K,
    LIG_L,
    LIG__ampersand_,
    LIG_Z,
    LIG_X,
    LIG_C,
    LIG_V,
    LIG_B,
    LIG_N,
    LIG_M,
    LIG_2,
    LIG_3,
    LIG__semicolon_,
    LIG__comma_,
    LIG__equal_,
    LIG__period_,
};

enum modifier_id {
    MOD_SHIFT,
    MOD_SHIFT_L,
    MOD_SHIFT_R,
};

#define AC_FN0 ACTION_MACRO(LIG__asciitilde_)
#define AC_FN1 ACTION_MACRO(LIG_Q)
#define AC_FN2 ACTION_MACRO(LIG_W)
#define AC_FN3 ACTION_MACRO(LIG_E)
#define AC_FN4 ACTION_MACRO(LIG_R)
#define AC_FN5 ACTION_MACRO(LIG_T)
#define AC_FN6 ACTION_MACRO(LIG_Y)
#define AC_FN7 ACTION_MACRO(LIG_U)
#define AC_FN8 ACTION_MACRO(LIG_I)
#define AC_FN9 ACTION_MACRO(LIG_O)
#define AC_FN10 ACTION_MACRO(LIG_P)
#define AC_FN11 ACTION_MACRO(LIG__parenleft_)
#define AC_FN12 ACTION_MACRO(LIG__parenright_)
#define AC_FN13 ACTION_MACRO(LIG_A)
#define AC_FN14 ACTION_MACRO(LIG_S)
#define AC_FN15 ACTION_MACRO(LIG_D)
#define AC_FN16 ACTION_MACRO(LIG_F)
#define AC_FN17 ACTION_MACRO(LIG_G)
#define AC_FN18 ACTION_MACRO(LIG_H)
#define AC_FN19 ACTION_MACRO(LIG_J)
#define AC_FN20 ACTION_MACRO(LIG_K)
#define AC_FN21 ACTION_MACRO(LIG_L)
#define AC_FN22 ACTION_MACRO(LIG__ampersand_)
#define AC_FN23 ACTION_FUNCTION_OPT(F_MODIFIER, MOD_SHIFT_L)
#define AC_FN24 ACTION_MACRO(LIG_Z)
#define AC_FN25 ACTION_MACRO(LIG_X)
#define AC_FN26 ACTION_MACRO(LIG_C)
#define AC_FN27 ACTION_MACRO(LIG_V)
#define AC_FN28 ACTION_MACRO(LIG_B)
#define AC_FN29 ACTION_MACRO(LIG_N)
#define AC_FN30 ACTION_MACRO(LIG_M)
#define AC_FN31 ACTION_FUNCTION_OPT(F_MODIFIER, MOD_SHIFT_R)
#define AC_FN32 ACTION_MACRO(LIG_2)
#define AC_FN33 ACTION_MACRO(LIG_3)
#define AC_FN34 ACTION_MACRO(LIG__semicolon_)
#define AC_FN35 ACTION_MACRO(LIG__comma_)
#define AC_FN36 ACTION_MACRO(LIG__equal_)
#define AC_FN37 ACTION_MACRO(LIG__period_)

#ifdef KEYMAP_SECTION_ENABLE
const action_t actionmaps[][UNIMAP_ROWS][UNIMAP_COLS] __attribute__ ((section (".keymap.keymaps"))) = {
#else
const action_t actionmaps[][UNIMAP_ROWS][UNIMAP_COLS] PROGMEM = {
#endif
    // None
    [0] = UNIMAP(
               F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24,
     ESC,       F1,  F2,  F3,  F4,  F5,  F6,  F7,  F8,  F9, F10, F11, F12,          PSCR,SLCK,PAUS,         VOLD,VOLU,MUTE,
     FN0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   0,  NO,  NO,JYEN,BSPC,      INS,HOME,PGUP,    NLCK,PSLS,PAST,PMNS,
     TAB, FN1, FN2, FN3, FN4, FN5, FN6, FN7, FN8, FN9,FN10,FN11,FN12,       NO,      DEL, END,PGDN,      P7,  P8,  P9,PPLS,
    CAPS,FN13,FN14,FN15,FN16,FN17,FN18,FN19,FN20,FN21,FN22, FN0,     NUHS, ENT,                          P4,  P5,  P6,PCMM,
    FN23,NUBS,FN24,FN25,FN26,FN27,FN28,FN29,FN30,  NO,  NO,SLSH,       RO,FN31,            UP,           P1,  P2,  P3,PENT,
    LCTL,LGUI,LALT,MHEN,           SPC,          HENK,KANA,RALT,RGUI, APP,RCTL,     LEFT,DOWN,RGHT,      P0,     PDOT,PEQL
    ),
    // Shift
    [1] = UNIMAP(
              TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,
    TRNS,     TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,          TRNS,TRNS,TRNS,         TRNS,TRNS,TRNS,
     GRV, GRV,FN32,FN33,TRNS,TRNS,  NO,TRNS,TRNS,TRNS,TRNS,   F,   T,TRNS,TRNS,     TRNS,TRNS,TRNS,    TRNS,TRNS,TRNS,TRNS,
    TRNS,   Q,   W,  NO,   R,   T,   Y,   U,   I,   O,FN34,FN35,FN36,     TRNS,     TRNS,TRNS,TRNS,    TRNS,TRNS,TRNS,TRNS,
    TRNS,  NO,   S,   D,   F,   G,   H,   J,   K,   L,SCLN, GRV,     TRNS,TRNS,                        TRNS,TRNS,TRNS,TRNS,
    TRNS,TRNS,   Z,  NO,   C,   V,   B,   N,   M,TRNS,FN37,FN34,     TRNS,TRNS,          TRNS,         TRNS,TRNS,TRNS,TRNS,
    TRNS,TRNS,TRNS,TRNS,          TRNS,          TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,     TRNS,TRNS,TRNS,    TRNS,     TRNS,TRNS
    ),
};

const macro_t *action_get_macro(keyrecord_t *record, uint8_t id, uint8_t opt) {
    switch (id) {
        case LIG__asciitilde_:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(GRV), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_Q:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(Q), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_W:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(W), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_E:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(E), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_R:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(R), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_T:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(T), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_Y:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(Y), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_U:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(U), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_I:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(I), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_O:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(O), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_P:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(P), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG__parenleft_:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(9), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG__parenright_:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(0), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_A:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(A), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_S:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(S), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_D:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(D), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_F:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(F), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_G:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(G), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_H:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(H), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_J:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(J), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_K:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(K), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_L:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(L), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG__ampersand_:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(7), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_Z:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(Z), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_X:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(X), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_C:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(C), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_V:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(V), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_B:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(B), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_N:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(N), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_M:
            return record->event.pressed ?
                   MACRO(SM(), CM(), D(LSFT), T(M), U(LSFT), RM(), END) :
                   MACRO_NONE;
        case LIG_2:
            return record->event.pressed ?
                   MACRO(SM(), CM(), T(2), RM(), END) :
                   MACRO_NONE;
        case LIG_3:
            return record->event.pressed ?
                   MACRO(SM(), CM(), T(3), RM(), END) :
                   MACRO_NONE;
        case LIG__semicolon_:
            return record->event.pressed ?
                   MACRO(SM(), CM(), T(SCLN), RM(), END) :
                   MACRO_NONE;
        case LIG__comma_:
            return record->event.pressed ?
                   MACRO(SM(), CM(), T(COMM), RM(), END) :
                   MACRO_NONE;
        case LIG__equal_:
            return record->event.pressed ?
                   MACRO(SM(), CM(), T(EQL), RM(), END) :
                   MACRO_NONE;
        case LIG__period_:
            return record->event.pressed ?
                   MACRO(SM(), CM(), T(DOT), RM(), END) :
                   MACRO_NONE;
    }
    return MACRO_NONE;
}

#define MOD_SHIFT_MASK (MOD_BIT(KC_LSFT)|MOD_BIT(KC_RSFT))

uint8_t vmods = 0;

const uint8_t layer_states[] = {
    0x1, // None
    0x3, // Shift
};

void action_function(keyrecord_t *record, uint8_t id, uint8_t opt) {
    uint8_t pressed = record->event.pressed;
    switch (id) {
        case F_MODIFIER:
            // Set the new modifier
            switch (opt) {
                case MOD_SHIFT: pressed ? add_key(KC_LSFT) : del_key(KC_LSFT); break;
                case MOD_SHIFT_L: pressed ? add_key(KC_LSFT) : del_key(KC_LSFT); break;
                case MOD_SHIFT_R: pressed ? add_key(KC_RSFT) : del_key(KC_RSFT); break;
            }

            // Update the layer
            uint8_t mods = get_mods();
            uint8_t layer_index = 0;
            layer_index |= mods & MOD_SHIFT_MASK ? 1 : 0;
            layer_index |= vmods << 1;
            layer_clear();
            layer_or(layer_states[layer_index]);
            break;
    }
}
